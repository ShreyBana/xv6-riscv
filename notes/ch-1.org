* Operating System Interfaces
** The conflict in designing a Kernel.
On one hand, one wants a simple & easy to understand interface & at the same time wants them to be very sophisticated & feature rich. This conflict in design has been solved by designing interfaces in a manner such that they rely on few mechanisms & can be easily composed.

** What is a Kernel ?
A kernel is a special program which provides access to the resources of the machine like storage, memory, networking etc.. Whenever a process needs to use any of these resources it's done via the kernel through something known as a *system call*. The kernel uses a hardware protection mechanisms provided by the CPU to ensure that each process executing in user space can only access it's own memory. When a user process invokes a system call, the hardware raises the privillage level & starts executing a pre-arranged function in the kernel.

** The Shell
It's a simple program which reads commands from the user & executes them. The fact that it's in user space shows the power of the kernel interfaces & how flexible they are.

** fork, wait & exec
When a process calls *fork*, a new(child) process is spawned with a copy of the memory of the calling(parent) process. The execution of this child process also begins from the point where the *fork* system call was made? *fork* returns the PID of the child process to the parent & '0' to the child process. It can also return *-1* if there's an error.

*NOTE* Most system calls, if not stated otherwise, returns 0 for no error & -1 if there is.

The *wait* system call, waits until a child exits & returns it's PID. It returns -1 if there are no children. Optionally a pointer can also be passed to *wait* to receive the exit status of the child.
#+begin_src C
  int exit_code = 0;
  int pid;
  pid = wait(&exit_code);
#+end_src
OR, if we don't care about the exit code
#+begin_src C
  int pid;
  pid = wait((int*) 0);
#+end_src

The *exec* system call replaces the memory of the calling process with a new memory image loaded from a file in a particular format. The format indicates which part is data, which part holds the instructions & which instruction to start from. Xv6 uses the ELF(executable & link-able format) format. When *exec* succeeds, it doesn't return to the calling program, instead execution starts as per the point declared in the ELF header. *exec* accepts 2 arguments, the name of the file & an array of arguments.
#+begin_src C
  char *argv[3];
  argv[0] = "echo";
  argv[1] = "hello";
  argv[2] = 0;
  exec("/bin/echo", argv);
  printf("exec error\n");
#+end_src
As one can see the first argument to the program is the name of the program itself, & so, most programs generally ignore the first argument.

The *shell* then, broadly speaking, is mostly a composition of these system calls. It reads the command from the user, forks & then executes the required program via *exec*. There is good reason why *exec* & *fork* aren't combined into a single call. The shell exploits this separation to handle I/O redirection in a clean way. One may think that is sub-optimal as we create a copy of the process & then immediately replace the memory via *exec*, but most operating kernels optimize the implementation of *fork* for this use case by using virtual memory techniques such as copy-on-write.

** File Descriptors
A file descriptor(FD) is a number representing a kernel managed object. Process's can acquire these by opening files, directories, devices, pipes or by duplicating an existing FD. FD's are meant to abstract away the differences b/w files, pipes & devices, & instead makes them all look like a stream of bytes.
Xv6 uses these FD's as an index into a per-process table, so that every process has it's own namespace of FD's starting at zero. Conventionally, a process reads from FD 0(stdin), writes output to FD 1(stdout), & writes error messages to FD 2(stderr). The shell exploits this convention to implement I/O redirection. The shell insures that there are 3 FD's for every process that it creates by default, & they all are FD's for the console.

*** read(fd, buf, n)
This sys-call reads at most n bytes from the FD into to the buffer & returns the number of bytes read. Each FD that refers to a file has an offset associated with it & a *read* call will advance the offset by the number of bytes read. When there are no more bytes left, *read* returns zero.

*** write(fd, buf, n)
It writes n bytes from the buffer into the FD provided & returns the number of bytes written. Fewer than n bytes are only returned when an error occurs. Like *read*, *write* is also associated with an offset & each write picks up from where the last write had stopped.

*** I/O redirection In The Shell
Simplified version of *cat*
#+begin_src C
  char buf[512];
  int n;

  for (;;) {
    n = read(0, buf, sizeof buf);

    if (n == 0) // No bytes left to read.
      break;
    else if (n < 0) { // Error while reading.
      fprintf(2, "read error\n");
      exit(1);
    } else if (write(1, buf, n) != n) { // Error while writing.
      fprintf(2, "write error\n");
      exit(1);
    }
  }
#+end_src

As we can see cat doesn't know where it's reading & writing to. So we could redirect the I/O by changing what those FD's point to. The standard way of doing it is to use *close*. The *close* sys-call releases an FD, making it free for re-use via an *open*, *pipe* or *dup* system call. A newly allocated FD is always the lowest-numbered descriptor available for that process.

FD's & *fork* interact to make I/O redirection easy to implement. When a child process is forked, the parent process's FD table is copied along with it's memory. With this behavior, the shell selectively reopens FD's & then calls *exec* to implement I/O redirection. Note *exec* only replaces the calling process, there is no effect on the FD table.

Simplified version of *cat < input.txt*
#+begin_src C
  char *argv[2];

  argv[0] = "cat";
  argv[1] = 0;
  if (fork() == 0) {
    close(0);
    open("input.txt", O_RDONLY);
    exec("cat", argv);
  }
#+end_src
So, we close stdout(FD 0) & then open the file where we want cat to read from. After closing, the smallest available FD, will be 0, so FD 0 will point to input.txt.

Although *fork* copies the FD table, the underlying file offsets are shared b/w the two process's. As an example:
#+begin_src C
    if(fork() == 0) {
      write(1, "hello ", 6);
      exit(0);
    } else {
      wait(0);
      write(1, "world\n", 6);
    }
#+end_src
This will print out "hello world". As the child prints "hello " & exits, the parent process will *wait* for the child's process's exit, after which it will print "world\n". This allows for sequential output from sequences of shell commands. Ex: *(echo hello;echo world)>output.txt*

The *dup* system call duplicates a FD, returning an FD referring to the same underlying I/O object. Both of these FD's share the offset, just like the ones duplicated by *fork*. This system call allows the shell to implement commands like:
#+begin_src sh
ls dir1 non-existant-dir > tmp1 2>&1
#+end_src
So both the stdout & stderr will show up in the file *tmp1*.

So FD's derived via a combination of *fork* & *dup* will share the offset, BUT not if created via *open*.
*** pipes
A pipe is a kernel buffer which is exposed via a pair of FD's. One for reading & one for writing. As one writes to the pipe, the written data gets available for reading. An interesting thing about pipe is that it blocks the read sys-call until new data is available to be read OR the write end has been closed.

**** piping to `wc`
#+begin_src C
  int p[2];
  char *argv[2];

  argv[0] = "wc";
  argv[1] = 0;

  pipe(p);
  if (fork() == 0) {
    close(0);
    // Now the read end of the pipe will become fd 0.
    dup(p[0]);
    close(p[0]);
    close(p[1]);
    exec("/bin/wc", argv);
  } else {
    close(p[0]);
    write(p[1], "hello world\n", 12);
    // Without this wc would not terminate as it would keep waiting for new
    // data to appear in the pipe.
    close(p[1]);
  }
#+end_src
which essentially translates to:
#+begin_src sh
  echo "hello world" | wc
#+end_src

**** diff w.r.t temporary files
Now, one can also use temp files as an alternative:
#+begin_src sh
  echo "hello world" > /tmp/f.txt; wc </tmp/f.txt; rm /tmp/f.txt
#+end_src
Pipes may seem to be essentially temporary files, but there are 3 key differences:
1. No clean up required.
2. You can stream data without worrying about size limitations.
3. They allow for parallel executing. In the case of a temp file, all the data has to
   written to file, before the second program can start executing.

** File System
The xv6 file system provides data files, which are uninterpreted byte arrays & directories, which contain named references to data files & other directories. Paths to files or directories can either be absolute or relative. If a path doesn't begin with a `/`, like `a/b/c`, they are evaluated from the process's current directory.

**** chdir & using relative & absolute paths
The `chdir` sys call can used to switch a process's current working directory.
#+begin_src C
  // Change dir to `/a`
  chdir("/a");
  // Change dir to `/a/b`
  chdir("b");
  // Opens the file `/a/b/c`
  open("c", O_RDONLY);

  // Can be alternatively opened via an absolute path as well.
  open("/a/b/c", O_RDONLY);
#+end_src

**** creating new files
There are 3 system calls avilable to create new file-like objects:
1. `mkdir` to create a new directory.
2. `open` w/ the O_CREATE flag to create a new file.
3. `mknod` to create a new device file.

#+begin_src C
  mkdir("/dir");
  fd = open("/dir/file", O_CREATE|O_WRONLY);
  close(fd);
  mknod("/console", 1, 1);
#+end_src
    
`mknod` creates a special file that refers to a device. It accepts 2 extra arguments, namely the major & minor device numbers, which uniquely identify a kernel device. When process's call `read` or `write` on such files, the kernel redirects to the kernel device driver implementation, instead of passing them to the file system. 

**** inodes
A file & it's name are separate. The underlying object, which represents a file, is known as an *inode*. An inode can have multiple names, called links. Each link is essentially an entry in a directory; the entry contains a file name & a reference to the inode.
An inode holds metadata about a file; it's type(dir, device or file), length, location of the file's content on the disk & the number of links to the inode.

***** fstat
The *fstat* system call retrieves information from the inode that a FD refers to.
From *stat.h*
#+begin_src C
  #define T_DIR 1
   // Directory
  #define T_FILE 2
   // File
  #define T_DEVICE 3
   // Device
  struct stat {
    int dev;
    // File system’s disk device
    uint ino;
    // Inode number
    short type; // Type of file
    short nlink; // Number of links to file
    uint64 size; // Size of file in bytes
  };
#+end_src

***** link & unlink
With the *link* system call, we can create another file name for an already existing file/inode.

#+begin_src C
  open("a", O_CREATE|O_WRONLY);
  link("a", "b");
#+end_src
Now reading from or writing to "a" is the same as doing it from "b". We can even verify that this inode has 2 links by calling the fstat sys call & inspecting the *nlink* field.
NOTE - Each inode number is unique within a file system.

Similar to link, we have *unlink*. As it sounds, it removes a name from the file system. Once an inode's links come down to zero, & no FD is referring to it, the inode & it's contents on the disk are freed.

***** idiomatic temp file
We can create a temp file which gets automatically cleaned up by the OS on process exit:
#+begin_src C
  fd = open("/tmp/file.txt", O_CREATE|O_RDWR);
  unlink("/tmp/file.txt");
#+end_src
Since the links to this inode are now zero, once the process exits, the FD will be released & this file will get cleaned up.
