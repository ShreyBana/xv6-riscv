* Operating System Interfaces
** The conlfict in designing a Kernel.
On one hand, one wants a simple & easy to understand interface & at the same time wants them to be very sophisticated & feature rich. This conflict in design has been solved by designing interfaces in a manner such that they rely on few mechanisms & can be easly composed.

** What is a Kernel ?
A kernel is a special program which provides access to the resources of the machine like storage, memory, networking etc.. Whenever a process needs to use any of these resources it's done via the kernel through something known as a *system call*. The kernel uses a hardware protection mechanisms provided by the CPU to ensure that each process executing in user space can only access it's own memory. When a user process invokes a system call, the hardware raises the privallage level & starts executing a pre-arranged function in the kernel.

** The Shell
It's a simple program which reads commands from the user & executes them. The fact that it's in user space shows the power of the kernel interfaces & how flexible they are.

** fork, wait & exec
When a process calls *fork*, a new(child) process is spawned with a copy of the memory of the calling(parent) process. The execution of this child process also begins from the point where the *fork* system call was made? *fork* returns the PID of the child process to the parent & '0' to the child process. It can also return *-1* if there's an error.

Most system calls, if not stated otherwise, returns 0 for no error & -1 if there is.

The *wait* system call, waits until a child exits & returns it's PID. It returns -1 if there are no children. Optionally a pointer can also be passed to *wait* to recieve the exit status of the child.
#+begin_src C
  int exit_code = 0;
  int pid;
  pid = wait(&exit_code);
#+end_src
OR, if we don't care about the exit code
#+begin_src C
  int pid;
  pid = wait((int*) 0);
#+end_src

The *exec* system call replaces the memory of the calling process with a new memory image loaded from a file in a particular format. The format indicates which part is data, which part holds the instructions & which instruction to start from. Xv6 uses the ELF(executable & linkable format) format. When *exec* succeeds, it doesn't return to the calling program, instead execution starts as per the point declared in the ELF header. *exec* accepts 2 arguments, the name of the file & an array of arguments.
#+begin_src C
  char *argv[3];
  argv[0] = "echo";
  argv[1] = "hello";
  argv[2] = 0;
  exec("/bin/echo", argv);
  printf("exec error\n");
#+end_src
As one can see the first argument to the program is the name of the program itself, & so, most programs generally ignore the first argument.

The *shell* then, broadly speaking, is mostly a composition of these system calls. It reads the command from the user, forks & then executes the required program via *exec*. There is good reason why *exec* & *fork* aren't combined into a single call. The shell exploits this separation to handle I/O redirection in a clean way. One may think that is sub-optimal as we create a copy of the process & then immediately repalce the memory via *exec*, but most operating kernels optimize the implementation of *fork* for this use case by using virtual memory techniques such as copy-on-write.

** File Descriptors
A file descriptor(FD) is a number represting a kernel managed object. Process's can acquire these by opening files, directories, devices, pipes or by duplicating an existing FD. FD's are meant abstract away the differences b/w files, pipes & devices, & instead makes them all look like a stream of bytes.
Xv6 uses these FD's as an index into a per-process table, so that every process has it's own namespace of FD's starting at zero. Conventionally, a process reads from FD 0(stdin), writes output to FD 1(stdout), & writes error messages to FD 2(stderr). The shell exploits this convention to implement I/O redirection. The shell insures that there are 3 FD's for every process that it creates by default, & they all are FD's for the console.

*** read(fd, buf, n)
This sys-call reads at most n bytes from the FD into to the buffer & returns the number of bytes read. Each FD that refers to a file has an offset associated with it & a *read* call will advance the offset by the number of bytes read. When there are no more bytes left, *read* returns zero.

*** write(fd, buf, n)
It writes n bytes from the buffer into the FD provided & returns the number of bytes written. Fewer than n bytes are only returned when an error occurs. Like *read*, *write* also advances the offest by the number of bytes written. 

*** I/O redirection In The Shell
Simplified version of *cat*
#+begin_src C
  char buf[512];
  int n;

  for (;;) {
    n = read(0, buf, sizeof buf);

    if (n == 0) // No bytes left to read.
      break;
    else if (n < 0) { // Error while reading.
      fprintf(2, "read error\n");
      exit(1);
    } else if (write(1, buf, n) != n) { // Error while writing.
      fprintf(2, "write error\n");
      exit(1);
    }
  }
#+end_src

As we can see cat doesn't know where it's reading & writing to. So we could redirect the I/O by changing what those FD's point to. The standard way of doing it is to use *close*. The *close* sys-call realses an FD, making it free for re-use via an *open*, *pipe* or *dup* system call. A newely allocated FD is always the lowest-numbered descriptor available for that process.

FD's & *fork* interact to make I/O redirection easy to implement. When a child process is forked, the parent process's FD table is copied along with it's memory. With this behaviour, the shell selectively reopens FD's & then calls *exec* to implement I/O redirection. Note *exec* only replaces the calling process, there is no effect on the FD table.

Simplfied version of *cat < input.txt*
#+begin_src C
  char *argv[2];

  argv[0] = "cat";
  argv[1] = 0;
  if (fork() == 0) {
    close(0);
    open("input.txt", O_RDONLY);
    exec("cat", argv);
  }
#+end_src
So, we close stdout(FD 0) & then open the file where we want cat to read from. After closing, the smallest available FD, will be 0, so FD 0 will point to input.txt.

Although *fork* copies the FD table, the underlying file offsets are shared b/w the two process's. As an example:
#+begin_src C
    if(fork() == 0) {
      write(1, "hello ", 6);
      exit(0);
    } else {
      wait(0);
      write(1, "world\n", 6);
    }
#+end_src
This will print out "hello world". As the child prints "hello " & exits, the parent process will *wait* for the child's process's exit, after which it will print "world\n". This allows for sequential output from sequences of shell commands. Ex: *(echo hello;echo world)>output.txt*

The *dup* system call duplicates a FD, returning an FD referring to the same underlying I/O object. Both of these FD's share the offset, just like the ones duplicated by *fork*. This system call allows the shell to implement commands like:
#+begin_src sh
ls dir1 non-existant-dir > tmp1 2>&1
#+end_src
So both the stdout & stderr will show up in the file *tmp1*.

So FD's dervided via a combination of *fork* & *dup* will share the offset, BUT not if created via *open*.
